package codegen

import (
	"fmt"
	"strings"
)

type JASM struct {
	code       *Code
	labelID    int
	pst        *StackType
	endIfLabel string
	elseLabel  string
}

func NewJASM() *JASM {
	return &JASM{
		code: NewCode(),
		pst:  NewStackType(),
	}
}

func (j *JASM) StartMainClass(name string) {
	j.addLine("// Code generated by POJ 0.1")
	j.addLine(fmt.Sprintf("public class %s {", name))
	j.incTab()
}

func (j *JASM) FinishMainClass() {
	j.decTab()
	j.addLine("}")
}

func (j *JASM) StartMain() {
	j.addLine("public static main([java/lang/String)V {")
	j.incTab()
}

func (j *JASM) AddOpcode(opcode string, parameters ...string) {
	params := strings.Join(parameters, " ")

	j.addLine(fmt.Sprintf("%s %s", opcode, params))
}

func (j *JASM) AddLdcStringOpcode(text string) {
	j.AddOpcode("ldc", text)
	j.pst.Push(String)
}

func (j *JASM) AddSiPushOpcode(number string) {
	j.AddOpcode("sipush", number)
	j.pst.Push(Integer)
}

func (j *JASM) AddPushTrue() {
	j.AddOpcode("iconst 1")
}

func (j *JASM) AddPushFalse() {
	j.AddOpcode("iconst 0")
}

func (j *JASM) AddGotoOpcode(label string) {
	j.AddOpcode("goto", label)
}

func (j *JASM) AddInvokeVirtualPrintWithType() {
	pt := j.pst.Pop()
	if pt == String {
		j.AddOpcode("invokevirtual", "java/io/PrintStream.print(java/lang/String)V")
	} else if pt == Integer {
		j.AddOpcode("invokevirtual", "java/io/PrintStream.print(I)V")
	} else {
		j.AddOpcode("undefined type in write/writeln")
	}
}

func (j *JASM) AddInvokeVirtualPrintln() {
	j.AddOpcode("invokevirtual", "java/io/PrintStream.println()V")
}

func (j *JASM) AddStaticPrintStream() {
	j.AddOpcode("getstatic", "java/lang/System.out", "java/io/PrintStream")
}

func (j *JASM) StartIfStatement() {
	j.elseLabel = j.newLabel()
	j.endIfLabel = j.newLabel()
}

func (j *JASM) EnterThenStatement() {
	j.AddOpcode("ifeq", j.elseLabel)
}

func (j *JASM) FinishThenStatement() {
	j.AddOpcode("goto", j.endIfLabel)
	j.AddLabel(j.elseLabel)
}

func (j *JASM) FinishIfStatement() {
	j.AddLabel(j.endIfLabel)
}

func (j *JASM) AddOperatorOpcode(op string) {
	pt1 := j.pst.Pop()
	pt2 := j.pst.Pop()
	if pt1 != pt2 {
		j.AddOpcode("invalid types")
		return
	}

	switch {
	case op == "and":
		switch pt1 {
		case Boolean:
			j.AddOpcode("iand")
			j.pst.Push(Boolean)
		default:
			j.AddOpcode("invalid type in boolean operator")
		}
	case op == "or":
		switch pt1 {
		case Boolean:
			j.AddOpcode("ior")
			j.pst.Push(Boolean)
		default:
			j.AddOpcode("invalid type in boolean operator")
		}
	case op == "*":
		switch pt1 {
		case Integer:
			j.genMulIntegers()
		default:
			j.AddOpcode("invalid type in mul")
		}
	case op == "/":
		switch pt1 {
		case Integer:
			j.genDivIntegers()
		default:
			j.AddOpcode("invalid type in div")
		}
	case op == "+":
		switch pt1 {
		case String:
			j.genAddStrings()
		case Integer:
			j.genAddIntegers()
		default:
			j.AddOpcode("invalid type in add")
		}
	case op == "-":
		switch pt1 {
		case Integer:
			j.genSubIntegers()
		default:
			j.AddOpcode("invalid type in sub")
		}
	case op == ">":
		switch pt1 {
		case Integer:
			j.genBooleanOperatorTpl("if_icmple")
		default:
			j.AddOpcode("invalid type in comparison")
		}
	case op == "<":
		switch pt1 {
		case Integer:
			j.genBooleanOperatorTpl("if_icmpge")
		default:
			j.AddOpcode("invalid type in comparison")
		}
	case op == ">=":
		switch pt1 {
		case Integer:
			j.genBooleanOperatorTpl("if_icmplt")
		default:
			j.AddOpcode("invalid type in comparison")
		}
	case op == "<=":
		switch pt1 {
		case Integer:
			j.genBooleanOperatorTpl("if_icmpgt")
		default:
			j.AddOpcode("invalid type in comparison")
		}
	case op == "=":
		switch pt1 {
		case Integer:
			j.genBooleanOperatorTpl("if_icmpne")
		default:
			j.AddOpcode("invalid type in comparison")
		}
	case op == "<>":
		switch pt1 {
		case Integer:
			j.genBooleanOperatorTpl("if_icmpeq")
		default:
			j.AddOpcode("invalid type in comparison")
		}
	}
}

func (j *JASM) AddUnaryOperatorOpcode(op string) {
	pt1 := j.pst.Pop()
	if pt1 != Boolean {
		j.AddOpcode("invalid type in unary operator")
		return
	}

	switch op {
	case "not":
		lfalse := j.newLabel()
		lnext := j.newLabel()
		j.AddOpcode("ifne", lfalse)
		j.AddPushTrue()
		j.AddGotoOpcode(lnext)
		j.AddLabel(lfalse)
		j.AddPushFalse()
		j.AddLabel(lnext)
		j.pst.Push(Boolean)
	}
}

func (j *JASM) AddLabel(label string) {
	j.addLine(fmt.Sprintf("%s:", label))
}

func (j *JASM) FinishMain() {
	j.addLine("return")
	j.decTab()
	j.addLine("}")
}

func (j *JASM) StartInvokeDynamic(param string) {
	j.addLine(fmt.Sprintf("invokedynamic %s {", param))
	j.incTab()
}

func (j *JASM) FinishInvokeDynamic() {
	j.decTab()
	j.addLine("}")
}

func (j *JASM) newLabel() string {
	j.labelID++
	return fmt.Sprintf("L%d", j.labelID)
}

func (j *JASM) Code() string {
	return j.code.Code()
}

func (j *JASM) addLine(line string) {
	j.code.AddLine(line)
}

func (j *JASM) incTab() {
	j.code.IncTab()
}

func (j *JASM) decTab() {
	j.code.DecTab()
}

func (j *JASM) genAddStrings() {
	j.StartInvokeDynamic(`makeConcatWithConstants(java/lang/String, java/lang/String)java/lang/String`)
	j.AddOpcode(`invokestatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants(java/lang/invoke/MethodHandles$Lookup, java/lang/String, java/lang/invoke/MethodType, java/lang/String, [java/lang/Object)java/lang/invoke/CallSite`)
	j.AddOpcode(`[""]`)
	j.FinishInvokeDynamic()
	j.pst.Push(String)
}

func (j *JASM) genAddIntegers() {
	j.AddOpcode("iadd")
	j.pst.Push(Integer)
}

func (j *JASM) genSubIntegers() {
	j.AddOpcode("isub")
	j.pst.Push(Integer)
}

func (j *JASM) genMulIntegers() {
	j.AddOpcode("imul")
	j.pst.Push(Integer)
}

func (j *JASM) genDivIntegers() {
	j.AddOpcode("idiv")
	j.pst.Push(Integer)
}

func (j *JASM) genBooleanOperatorTpl(ifOpcode string) {
	lfalse := j.newLabel()
	lnext := j.newLabel()
	j.AddOpcode(ifOpcode, lfalse)
	j.AddPushTrue()
	j.AddGotoOpcode(lnext)
	j.AddLabel(lfalse)
	j.AddPushFalse()
	j.AddLabel(lnext)
	j.pst.Push(Boolean)
}
