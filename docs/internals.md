# Internals

Aqui iremos detalhar o Java Assembly gerado pelo POJ. Para tal, utilizaremos os exemplos existentes na pasta "tests".


## Saída de dados (leia-se "Hello world!")

Nada melhor do que iniciarmos por um exemplo simples: o "Hello world!".

A partir do programa [hello_world.pas](/tests/valid_pascal_programs/hello_world.pas):

```
program Hello;
begin
  writeln ('Hello world!');
end.
```

O POJ gera o seguinte Java Assembly ([hello_world.jasm](/tests/valid_pascal_programs/hello_world.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class hello_world {
 3:     public static main([java/lang/String)V {
 4:         getstatic java/lang/System.out java/io/PrintStream
 5:         ldc "Hello world!"
 6:         invokevirtual java/io/PrintStream.print(java/lang/String)V
 7:         getstatic java/lang/System.out java/io/PrintStream
 8:         invokevirtual java/io/PrintStream.println()V
 9:         return
10:     }
11: }
```

Como o propósito inicial da JVM era apenas executar as aplicações Java, sua estrutura e suas instruções refletem muito a estrutura do JAVA em si. Um Assembly Java válido é composto pela definição de uma classe (hello_world na linha 2) e de seus métodos (no exemplo acima apenas o main na linha 3). E, dentro dos métodos, as instruções a serem executadas (getstatic, ldc, etc. nas linhas de 4 a 9).

Vale aqui ressaltar que a JVM é uma [_stack based machine_](https://en.wikipedia.org/wiki/Stack_machine), ou seja, é uma máquina baseada em pilha. Isso quer dizer que suas instruções utilizam uma pilha interna para realizar as suas operações.

No _assembly_ acima getstatic, ldc, invokevirtual e return são mnemônicos do _Java Assembly_. Possuem a seguinte finalidade:
- getstatic: obtém uma referência de um método estático de uma classe
- ldc: empilha a constante
- invokevirtual: desempilha dois valores (método a ser invocado e parâmetro) e executa
- return: finaliza a execução do método


Na prática o par getstatic/invokevirtual serve para invocar o método print, responsável por enviar dados para a saída padrão. O "java/lang/String" em print(java/lang/String) indica que será exibido uma string. E para saber qual método print invocar, o POJ precisa fazer o _tracking_ dos tipos de dados que estão sendo empilhados/desempilhados na JVM.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic java/lang/System.out java/io/PrintStream | [ java/io/PrintStream ] |
| ldc "Hello world!" | [ java/io/PrintStream, "Hello world!" ] |
| invokevirtual java/io/PrintStream.print(java/lang/String)V | [\<vazia\>] |
| getstatic java/lang/System.out java/io/PrintStream | [ java/io/PrintStream ] |
| invokevirtual java/io/PrintStream.println()V | [\<vazia\> ] |
| return | [\<vazia\>] |


## Leitura de dados

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
program HelloName;
var
  myname: string;
begin
  write('What is your name? '); readln(myname);
  writeln;
  writeln('Hello ', myname);
end.
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class hello_name {
 3:     public static myname java/lang/String
 4:     public static main([java/lang/String)V {
 5:         getstatic java/lang/System.out java/io/PrintStream
 6:         ldc "What is your name? "
 7:         invokevirtual java/io/PrintStream.print(java/lang/String)V
 8:         invokestatic java/lang/System.console()java/io/Console
 9:         invokevirtual java/io/Console.readLine()java/lang/String
10:         putstatic hello_name.myname java/lang/String
11:         getstatic java/lang/System.out java/io/PrintStream
12:         invokevirtual java/io/PrintStream.println()V
13:         getstatic java/lang/System.out java/io/PrintStream
14:         ldc "Hello "
15:         invokevirtual java/io/PrintStream.print(java/lang/String)V
16:         getstatic java/lang/System.out java/io/PrintStream
17:         getstatic hello_name.myname java/lang/String
18:         invokevirtual java/io/PrintStream.print(java/lang/String)V
19:         getstatic java/lang/System.out java/io/PrintStream
20:         invokevirtual java/io/PrintStream.println()V
21:         return
22:     }
23: }
```

No _assembly_ acima temos as seguintes novidades:
- definição da variável myname: isso ocorre na linha 3
- leitura de dados da entrada padrão (stdin): isso ocorre através do readLine() na linha 9 que lê uma informação e insere na pilha
- armazenamento da informação na variável myname: isso ocorre através do putstatic na linha 10 que remove a última informação da pilha e armazena o conteúdo na variável informada


## Concatenação de strings

A partir do programa [concat_two_strings.pas](/tests/valid_pascal_programs/concat_two_strings.pas):

```
program ConcatStrings;
begin
  writeln ('Hello ' + 'world!');
end.
```

O POJ gera o seguinte Java Assembly ([concat_two_strings.jasm](/tests/valid_pascal_programs/concat_two_strings.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class concat_two_strings {
 3:     public static main([java/lang/String)V {
 4:         getstatic java/lang/System.out java/io/PrintStream
 5:         ldc "Hello "
 6:         ldc "world!"
 7:         invokedynamic makeConcatWithConstants(java/lang/String, java/lang/String)java/lang/String {
                invokestatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants(java/lang/invoke/MethodHandles$Lookup, java/lang/String, java/lang/invoke/MethodType, java/lang/String, [java/lang/Object)java/lang/invoke/CallSite 
                [""] 
            }
 8:         invokevirtual java/io/PrintStream.print(java/lang/String)V
 9:         getstatic java/lang/System.out java/io/PrintStream
10:         invokevirtual java/io/PrintStream.println()V
11:         return
12:     }
13: }
```

No _assembly_ acima temos apenas o uso do método StringConcatFactory.makeConcatWithConstants (linha 7) que desempilha 2 valores strings, concatena e armazena o resultado na pilha. Na linha 8 o print retira o resultado da concatenação da pilha e imprime.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| ldc "Hello " | [java/io/PrintStream, "Hello "] |
| ldc "world!" | [java/io/PrintStream, "Hello ", "world!"] |
| invokedynamic makeConcatWithConstants(...) | [java/io/PrintStream, "Hello world!"] |
| invokevirtual java/io/PrintStream.print(java/lang/String)V |  [\<vazia\>] | 
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| invokevirtual java/io/PrintStream.println()V |  [\<vazia\>] | 
| return | [\<vazia\>] | 

## Operadores aritméticos

A partir do programa [add_two_numbers.pas](/tests/valid_pascal_programs/add_two_numbers.pas):

```
program AddTwoNumbers;
begin
  writeln (1+2);
end.
```

O POJ gera o seguinte Java Assembly ([add_two_numbers.jasm](/tests/valid_pascal_programs/add_two_numbers.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class add_two_numbers {
 3:     public static main([java/lang/String)V {
 4:         getstatic java/lang/System.out java/io/PrintStream
 5:         sipush 1
 6:         sipush 2
 7:         iadd 
 8:         invokevirtual java/io/PrintStream.print(I)V
 9:         getstatic java/lang/System.out java/io/PrintStream
10:         invokevirtual java/io/PrintStream.println()V
11:         return
12:     }
13: }
```

No _assembly_ acima temos as seguintes novidades:
- empilha inteiro informado (sipush): os inteiros 1 e 2 são colocados na pilha nas linhas 5 e 6, respectivamente
- desempilha dois inteiros, soma e empilha o resultado (iadd): desempilha 1, 2, executa a soma (3) e empilha

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| sipush 1 | [java/io/PrintStream, 1] |
| sipush 2 | [java/io/PrintStream, 1, 2] |
| iadd  | [java/io/PrintStream, 3] |
| invokevirtual java/io/PrintStream.print(I)V | [\<vazia\>] |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| invokevirtual java/io/PrintStream.println()V | [\<vazia\>] |
| return | [\<vazia\>] |

Assim como o operator '+' é traduzido para iadd, os operadores '-', '*' e '/' são traduzidos, respectivamente, para as instruções isub, imul e idiv.

Segue abaixo o exemplo [all_numeric_operators.pas](/tests/valid_pascal_programs/all_numeric_operators.pas) que utiliza todos os operadores:

```
program AllNumericOperators;
begin
  writeln (1+1, 2-2, 3*3, 4/4);
end.
```

A partir deste exemplo O POJ gera o seguinte Java Assembly ([all_numeric_operators.jasm](/tests/valid_pascal_programs/all_numeric_operators.jasm)):

```
// Code generated by POJ 0.1
public class all_numeric_operators {
	public static main([java/lang/String)V {
		getstatic java/lang/System.out java/io/PrintStream
		sipush 1
		sipush 1
		iadd 
		invokevirtual java/io/PrintStream.print(I)V
		getstatic java/lang/System.out java/io/PrintStream
		sipush 2
		sipush 2
		isub 
		invokevirtual java/io/PrintStream.print(I)V
		getstatic java/lang/System.out java/io/PrintStream
		sipush 3
		sipush 3
		imul 
		invokevirtual java/io/PrintStream.print(I)V
		getstatic java/lang/System.out java/io/PrintStream
		sipush 4
		sipush 4
		idiv 
		invokevirtual java/io/PrintStream.print(I)V
		getstatic java/lang/System.out java/io/PrintStream
		invokevirtual java/io/PrintStream.println()V
		return
	}
}
```

Como estamos abordando operadores aritméticos, faz-se necessário lidarmos com a precedência de operadores.

A partir do programa [operator_precedence_one_test.pas](/tests/valid_pascal_programs/operator_precedence_one_test.pas):

```
program OpPrecedence;
begin
  write(10-4*2, (10-4)*2); // 2 e 12
end.
```

O POJ gera o seguinte Java Assembly ([operator_precedence_one_test.jasm](/tests/valid_pascal_programs/operator_precedence_one_test.jasm)):

```
// Code generated by POJ 0.1
public class operator_precedence_one_test {
	public static main([java/lang/String)V {
		getstatic java/lang/System.out java/io/PrintStream
		sipush 10
		sipush 4
		sipush 2
		imul 
		isub 
		invokevirtual java/io/PrintStream.print(I)V
		getstatic java/lang/System.out java/io/PrintStream
		sipush 10
		sipush 4
		isub 
		sipush 2
		imul 
		invokevirtual java/io/PrintStream.print(I)V
		return
	}
}
```

No _assembly_ acima é possível notar que os inteiros são empilhados na ordem que aparecem no programa, mas as operações ocorrem conforme a precedência de cada uma. No caso de "10-4*2", primeiro é executado a multiplicação para depois a subtração. No caso de "(10-4)*2", como os parênteses tem precedência, primeiro é executado a subtração para posteriormente a multiplicação.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| sipush 10 | [java/io/PrintStream, 10] |
| sipush 4 | [java/io/PrintStream, 10, 4] |
| sipush 2 | [java/io/PrintStream, 10, 4, 2] |
| imul | [java/io/PrintStream, 10, 8] |
| isub | [java/io/PrintStream, 2] |
| invokevirtual java/io/PrintStream.print(I)V | [\<vazia\>] | 
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| sipush 10 |  [java/io/PrintStream, 10] |
| sipush 4 |  [java/io/PrintStream, 10, 4] |
| isub |  [java/io/PrintStream, 6] |
| sipush 2 |  [java/io/PrintStream, 6, 2] |
| imul |  [java/io/PrintStream, 12] |
| invokevirtual java/io/PrintStream.print(I)V | [\<vazia\>] | 
| return | [\<vazia\>] | 


## If/Then/Else

Exemplo com If/Then

Exemplo com If/Then/Else

Exemplos com sentenças aninhadas



A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```

## Operadores booleanos And, Or e Not

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```

## Declaração de variáveis

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```


## Estrutura de controle Repeat

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```


## Estrutura de controle While

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```


## Estrutura de controle For

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```

## Operadores relacionais para strings

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```

## Operadores relacionais para inteiros
A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```


## Definição e uso de procedures

Exemplos com e sem argumentos

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```

## Definição e uso de functions

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```


## Exemplo completo do fatorial recursivo

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
```





# REAPROVEITAR TALVEZ


acima getstatic, sipush, imul, idiv, invokevirtual e return são mnemônicos do _Java Assembly_. Possuem a seguinte finalidade:
- getstatic: obtém uma referência de um método estático de uma classe
- sipush \<N\>: empilha o inteiro N
- imul: desempilha dois inteiros e empilha a multiplicação destes valores
- idiv: desempilha dois inteiros e empilha a divisão destes valores
- invokevirtual: desempilha dois valores (método a ser invocado e parâmetro) e executa
- return: finaliza a execução do método

Na prática o par getstatic/invokevirtual serve para invocar o println, responsável por enviar dados para a saída padrão. O "I" em println(I) indica que será exibido um inteiro. E para saber qual método println invocar, o POJ precisa fazer o _tracking_ dos tipos de dados que estão sendo empilhados/desempilhados na JVM.





Segue abaixo o que significa cada instrução acima:
- getstatic
- ldc
- invokevirtual
- return



