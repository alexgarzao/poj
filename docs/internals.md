# Internals

Aqui iremos detalhar a etapa de geração de código do POJ, etapa onde o Java Assembly é gerado. Para tal, utilizaremos os exemplos existentes na pasta "tests" deste projeto.


## Saída de dados (leia-se "Hello world!")

Nada melhor do que iniciarmos por um exemplo simples: o "Hello world!".

A partir do programa [hello_world.pas](/tests/valid_pascal_programs/hello_world.pas):

```
program Hello;
begin
    writeln ('Hello world!');
end.
```

O POJ gera o seguinte Java Assembly ([hello_world.jasm](/tests/valid_pascal_programs/hello_world.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class hello_world {
 3:     public static main([java/lang/String)V {
 4:         getstatic java/lang/System.out java/io/PrintStream
 5:         ldc "Hello world!"
 6:         invokevirtual java/io/PrintStream.print(java/lang/String)V
 7:         getstatic java/lang/System.out java/io/PrintStream
 8:         invokevirtual java/io/PrintStream.println()V
 9:         return
10:     }
11: }
```

Como o propósito inicial da JVM era apenas executar as aplicações Java, sua estrutura e suas instruções refletem muito a estrutura do JAVA em si. Um Assembly Java válido é composto pela definição de uma classe (hello_world na linha 2) e de seus métodos (no exemplo acima apenas o main na linha 3). E, dentro dos métodos, as instruções a serem executadas (getstatic, ldc, etc. nas linhas de 4 a 9).

Vale aqui ressaltar que a JVM é uma [_stack based machine_](https://en.wikipedia.org/wiki/Stack_machine), ou seja, é uma máquina baseada em pilha. Isso quer dizer que suas instruções utilizam uma pilha interna para realizar as suas operações.

No _assembly_ acima as palavras getstatic, ldc, invokevirtual e return são mnemônicos do _Java Assembly_. Possuem a seguinte finalidade:
- getstatic: obtém uma referência de um método estático de uma classe
- ldc: empilha a constante
- invokevirtual: desempilha dois valores (método a ser invocado e parâmetro) e executa
- return: finaliza a execução do método

Na prática o par getstatic/invokevirtual serve para invocar o método print, responsável por enviar dados para a saída padrão (stdout). O parâmetro "java/lang/String" em print(java/lang/String) indica que será exibido uma string.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic java/lang/System.out java/io/PrintStream | [ java/io/PrintStream ] |
| ldc "Hello world!" | [ java/io/PrintStream, "Hello world!" ] |
| invokevirtual java/io/PrintStream.print(java/lang/String)V | [\<vazia\>] |
| getstatic java/lang/System.out java/io/PrintStream | [ java/io/PrintStream ] |
| invokevirtual java/io/PrintStream.println()V | [\<vazia\> ] |
| return | [\<vazia\>] |


## Leitura de dados

A partir do programa [hello_name.pas](/tests/valid_pascal_programs/hello_name.pas):

```
program HelloName;
var
    myname: string;
begin
    write('What is your name? '); readln(myname);
    writeln;
    writeln('Hello ', myname);
end.
```

O POJ gera o seguinte Java Assembly ([hello_name.jasm](/tests/valid_pascal_programs/hello_name.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class hello_name {
 3:     public static myname java/lang/String
 4:     public static main([java/lang/String)V {
 5:         getstatic java/lang/System.out java/io/PrintStream
 6:         ldc "What is your name? "
 7:         invokevirtual java/io/PrintStream.print(java/lang/String)V
 8:         invokestatic java/lang/System.console()java/io/Console
 9:         invokevirtual java/io/Console.readLine()java/lang/String
10:         putstatic hello_name.myname java/lang/String
11:         getstatic java/lang/System.out java/io/PrintStream
12:         invokevirtual java/io/PrintStream.println()V
13:         getstatic java/lang/System.out java/io/PrintStream
14:         ldc "Hello "
15:         invokevirtual java/io/PrintStream.print(java/lang/String)V
16:         getstatic java/lang/System.out java/io/PrintStream
17:         getstatic hello_name.myname java/lang/String
18:         invokevirtual java/io/PrintStream.print(java/lang/String)V
19:         getstatic java/lang/System.out java/io/PrintStream
20:         invokevirtual java/io/PrintStream.println()V
21:         return
22:     }
23: }
```

No _assembly_ acima temos as seguintes novidades:
- na linha 3 ocorre a definição da variável myname
- na linha 9 ocorre a leitura de dados da entrada padrão (stdin): método readLine() lê uma informação de stdin e insere na pilha
- na linha 10 ocorre o armazenamento da informação (que está na pilha) na variável myname: putstatic desempilha a última informação da pilha e armazena o conteúdo na variável informada


## Concatenação de strings

A partir do programa [concat_two_strings.pas](/tests/valid_pascal_programs/concat_two_strings.pas):

```
program ConcatStrings;
begin
    writeln ('Hello ' + 'world!');
end.
```

O POJ gera o seguinte Java Assembly ([concat_two_strings.jasm](/tests/valid_pascal_programs/concat_two_strings.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class concat_two_strings {
 3:     public static main([java/lang/String)V {
 4:         getstatic java/lang/System.out java/io/PrintStream
 5:         ldc "Hello "
 6:         ldc "world!"
 7:         invokedynamic makeConcatWithConstants(java/lang/String, java/lang/String)java/lang/String {
                invokestatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants(java/lang/invoke/MethodHandles$Lookup, java/lang/String, java/lang/invoke/MethodType, java/lang/String, [java/lang/Object)java/lang/invoke/CallSite 
                [""] 
            }
 8:         invokevirtual java/io/PrintStream.print(java/lang/String)V
 9:         getstatic java/lang/System.out java/io/PrintStream
10:         invokevirtual java/io/PrintStream.println()V
11:         return
12:     }
13: }
```

No _assembly_ acima temos apenas o uso do método StringConcatFactory.makeConcatWithConstants (linha 7) que desempilha 2 valores strings, concatena e armazena o resultado na pilha. Na linha 8 o print retira o resultado da concatenação da pilha e imprime.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| ldc "Hello " | [java/io/PrintStream, "Hello "] |
| ldc "world!" | [java/io/PrintStream, "Hello ", "world!"] |
| invokedynamic makeConcatWithConstants(...) | [java/io/PrintStream, "Hello world!"] |
| invokevirtual java/io/PrintStream.print(java/lang/String)V |  [\<vazia\>] | 
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| invokevirtual java/io/PrintStream.println()V |  [\<vazia\>] | 
| return | [\<vazia\>] | 

## Operadores aritméticos

A partir do programa [add_two_numbers.pas](/tests/valid_pascal_programs/add_two_numbers.pas):

```
program AddTwoNumbers;
begin
    writeln (1+2);
end.
```

O POJ gera o seguinte Java Assembly ([add_two_numbers.jasm](/tests/valid_pascal_programs/add_two_numbers.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class add_two_numbers {
 3:     public static main([java/lang/String)V {
 4:         getstatic java/lang/System.out java/io/PrintStream
 5:         sipush 1
 6:         sipush 2
 7:         iadd 
 8:         invokevirtual java/io/PrintStream.print(I)V
 9:         getstatic java/lang/System.out java/io/PrintStream
10:         invokevirtual java/io/PrintStream.println()V
11:         return
12:     }
13: }
```

No _assembly_ acima temos as seguintes novidades:
- empilha inteiro informado (sipush): os inteiros 1 e 2 são colocados na pilha nas linhas 5 e 6, respectivamente
- desempilha dois inteiros, soma e empilha o resultado (iadd): desempilha 1, 2, executa a soma (3) e empilha

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| sipush 1 | [java/io/PrintStream, 1] |
| sipush 2 | [java/io/PrintStream, 1, 2] |
| iadd  | [java/io/PrintStream, 3] |
| invokevirtual java/io/PrintStream.print(I)V | [\<vazia\>] |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| invokevirtual java/io/PrintStream.println()V | [\<vazia\>] |
| return | [\<vazia\>] |

Assim como o operator '+' é traduzido para iadd, os operadores '-', '*' e '/' são traduzidos, respectivamente, para as instruções isub, imul e idiv.

Segue abaixo o exemplo [all_numeric_operators.pas](/tests/valid_pascal_programs/all_numeric_operators.pas) que utiliza todos os operadores:

```
program AllNumericOperators;
begin
    writeln (1+1, 2-2, 3*3, 4/4);
end.
```

A partir deste exemplo O POJ gera o seguinte Java Assembly ([all_numeric_operators.jasm](/tests/valid_pascal_programs/all_numeric_operators.jasm)):

```
// Code generated by POJ 0.1
public class all_numeric_operators {
    public static main([java/lang/String)V {
        getstatic java/lang/System.out java/io/PrintStream
        ;; 1+1
        sipush 1
        sipush 1
        iadd
        invokevirtual java/io/PrintStream.print(I)V

        getstatic java/lang/System.out java/io/PrintStream
        ;; 2-2        
        sipush 2
        sipush 2
        isub 
        invokevirtual java/io/PrintStream.print(I)V

        getstatic java/lang/System.out java/io/PrintStream
        ;; 3*3
        sipush 3
        sipush 3
        imul 
        invokevirtual java/io/PrintStream.print(I)V

        getstatic java/lang/System.out java/io/PrintStream
        ;; 4/4
        sipush 4
        sipush 4
        idiv 
        invokevirtual java/io/PrintStream.print(I)V

        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V
        return
    }
}
```

Como estamos abordando operadores aritméticos, faz-se necessário lidarmos com a precedência de operadores.

A partir do programa [operator_precedence_one_test.pas](/tests/valid_pascal_programs/operator_precedence_one_test.pas):

```
program OpPrecedence;
begin
    write(10-4*2, (10-4)*2); // 2 e 12
end.
```

O POJ gera o seguinte Java Assembly ([operator_precedence_one_test.jasm](/tests/valid_pascal_programs/operator_precedence_one_test.jasm)):

```
// Code generated by POJ 0.1
public class operator_precedence_one_test {
    public static main([java/lang/String)V {

        getstatic java/lang/System.out java/io/PrintStream
        ;; 10-4*2
        sipush 10
        sipush 4
        sipush 2
        imul 
        isub 
        invokevirtual java/io/PrintStream.print(I)V

        getstatic java/lang/System.out java/io/PrintStream
        ;; (10-4)*2
        sipush 10
        sipush 4
        isub 
        sipush 2
        imul 
        invokevirtual java/io/PrintStream.print(I)V

        return
    }
}
```

No _assembly_ acima é possível notar que os inteiros são empilhados na ordem que aparecem no programa, mas as operações ocorrem conforme a precedência de cada uma. No caso de "10-4*2", primeiro é executado a multiplicação para depois a subtração. No caso de "(10-4)*2", como os parênteses tem precedência, primeiro é executado a subtração para posteriormente a multiplicação.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Instrução | Estado pilha após instrução |
| --------- | --------- |
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| sipush 10 | [java/io/PrintStream, 10] |
| sipush 4 | [java/io/PrintStream, 10, 4] |
| sipush 2 | [java/io/PrintStream, 10, 4, 2] |
| imul | [java/io/PrintStream, 10, 8] |
| isub | [java/io/PrintStream, 2] |
| invokevirtual java/io/PrintStream.print(I)V | [\<vazia\>] | 
| getstatic ... java/io/PrintStream | [java/io/PrintStream] |
| sipush 10 |  [java/io/PrintStream, 10] |
| sipush 4 |  [java/io/PrintStream, 10, 4] |
| isub |  [java/io/PrintStream, 6] |
| sipush 2 |  [java/io/PrintStream, 6, 2] |
| imul |  [java/io/PrintStream, 12] |
| invokevirtual java/io/PrintStream.print(I)V | [\<vazia\>] | 
| return | [\<vazia\>] | 


## Sentença If

Para podermos utilizar a sentença If é necessário implementarmos os operadores relacionais, que são: >, <, >=, <=, = e <>.

### Exemplo com If (sem else)

Vamos a um exemplo com if/then e o operador >. A partir do programa [if_without_else.pas](/tests/valid_pascal_programs/if_without_else.pas):


```
program IfWithoutElse;
begin
    if ( 111 > 222 ) then
        write('true');
end.
```

O POJ gera o seguinte Java Assembly ([if_without_else.jasm](/tests/valid_pascal_programs/if_without_else.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class if_without_else {
 3:     public static main([java/lang/String)V {
 4:         sipush 111
 5:         sipush 222
 6:         if_icmple L4
 7:         iconst 1 
 8:         goto L5
 9:     L4: iconst 0 
10:     L5: ifeq L1
11:         getstatic java/lang/System.out java/io/PrintStream
12:         ldc "true"
13:         invokevirtual java/io/PrintStream.print(java/lang/String)V
14:         goto L2
15: L1: L2: return
16:     }
17: }
```

No _assembly_ acima temos as seguintes novidades:
- labels: no exemplo acima "L1", "L2", "L4" e "L5"
- if_icmple \<label\>: desempilha dois inteiros e salta para o label indicado se o primeiro valor for menor ou igual ao segundo
- ifeq \<label\>: desempilha inteiro e salta para o label indicado se o valor for zero
- iconst \<N\>: carrega a constante inteira N na pilha
- goto \<label\>: salta para o label indicado

No Assembly acima é possível notar que, apesar do código gerado estar correto, o goto da linha 14 é desnecessário. Sim, realmente é. Porém, é normal um compilador (na fase de geração de código) gerar código desnecessário para alguns casos. Estas otimizações (e outras mais) são realizadas na etapa de otimização de código, algo que não existe no POJ atualmente.

A instrução if_icmple faz parte de um [conjunto amplo de instruções](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions) de teste e salto. O "le" (de if_icmple) é a abreviatura de "_less or equal_". Outras variações são gt (_greater than_), eq (_equal_), ne (_not equal_), lt (_less than_) e ge (_greater or equal_).

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Label   | Instrução | Estado pilha após instrução |
| ------- | --------- | --------- |
|         | sipush 111 | [111] |
|         | sipush 222 | [111,222] |
|         | if_icmple L4 | [\<vazia\>] |
|         | iconst 1 | [1] |
|         | goto L5 | [1] |
|  L4:    | ~~iconst 0~~ | |
|  L5:    | ifeq L1 | [\<vazia\>] |
|         | getstatic ... java/io/PrintStream | [java/io/PrintStream] |
|         | ldc "true" | [java/io/PrintStream, "true"] |
|         | invokevirtual java/io/PrintStream.print(java/lang/String)V | [\<vazia\>] |
|         | goto L2 | [\<vazia\>] |
| L1: L2: | return | [\<vazia\>] |

As instruções ~~marcadas desta forma~~ não são executadas durante o fluxo de execução deste programa.

No final da execução o programa exibe a saída esperada: "true".

Vale ressaltar que a condição utilizada na geração do assembly (if_icmple) é a inversa do programa em pascal (>). Esta técnica facilita a geração do assembly para os casos onde a sentença if somente tem o então (then), sem o senão (else).


### Exemplo com If e Else

Vamos a um exemplo com if/then/else. A partir do programa [if_with_else.pas](/tests/valid_pascal_programs/if_with_else.pas):


```
program IfWithElse;
begin
    if ( 111 > 222 ) then
        write('true')
    else begin
        write('false');
    end;
end.

```

O POJ gera o seguinte Java Assembly ([if_with_else.jasm](/tests/valid_pascal_programs/if_with_else.jasm)):

```
 1: // Code generated by POJ 0.1
 2: public class if_with_else {
 3:     public static main([java/lang/String)V {
 4:         sipush 111
 5:         sipush 222
 6:         if_icmple L4
 7:         iconst 1 
 8:         goto L5
 9: L4:     iconst 0 
10: L5:     ifeq L1
11:         getstatic java/lang/System.out java/io/PrintStream
12:         ldc "true"
13:         invokevirtual java/io/PrintStream.print(java/lang/String)V
14:         goto L2
15: L1:     getstatic java/lang/System.out java/io/PrintStream
16:         ldc "false"
17:         invokevirtual java/io/PrintStream.print(java/lang/String)V
18: L2:     return
19:     }
20: }
```

No Assembly acima é possível notar que não temos mais o goto desnecessário. Isso ocorre porque na geração do assembly o POJ utiliza um template de geração que funciona para os casos onde o if tem ou não o else. O código assembly é gerado a medida que o parser avança na leitura dos tokens, e por isso o POJ não sabe, quando inicia a leitura da sentença if, se existe ou não um else.

Na tabela abaixo é possível ver as instruções geradas a partir do _assembly_ acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Label   | Instrução | Estado pilha após instrução |
| ------- | --------- | --------- |
|         | sipush 111 | [111] |
|         | sipush 222 | [111,222] |
|         | if_icmple L4 | [\<vazia\>] |
|         | iconst 1 | [1] |
|         | goto L5 | [1] |
|  L4:    | ~~iconst 0~~ | |
|  L5:    | ifeq L1 | [\<vazia\>] |
|         | getstatic ... java/io/PrintStream | [java/io/PrintStream] |
|         | ldc "true" | [java/io/PrintStream, "true"] |
|         | invokevirtual java/io/PrintStream.print(java/lang/String)V | [\<vazia\>] |
|         | goto L2 | [\<vazia\>] |
| L1:     | ~~getstatic ... java/io/PrintStream~~ | |
|         | ~~ldc "false"~~ | |
|         | ~~invokevirtual java/io/PrintStream.print(java/lang/String)V~~ | |
| L2:     | return | [\<vazia\>] |

As instruções ~~marcadas desta forma~~ não são executadas durante o fluxo de execução deste programa.

No final da execução o programa exibe a saída esperada: "true".

Os exemplos acima não utilizaram todos, mas a lista completa de operadores relacionais para inteiros são:
- if_icmple: <=
- if_icmpgt: >
- if_icmpeq: ==
- if_icmpne: !=
- if_icmplt: <
- if_icmpge: >=


## Operador booleano and

Para implementarmos o operador booleano _and_ foi necessário introduzir a seguinte instrução:
- iand: desempilha dois inteiros, executa o _and_ e empilha o resultado

Vamos a um exemplo. A partir do programa Pascal abaixo:

```
program IfWithAnd;
begin
    if (111<222) and (222<333 ) then
        write('true')
    else
        write('false');
end.
```

O POJ gera o seguinte JASM:

```
// Code generated by POJ 0.1
public class if_with_and {
    public static main([java/lang/String)V {
        sipush 111
        sipush 222
        if_icmpge L4    ;; se 111 >= 222 salta para L4
        iconst 1        ;; carrega true (1) na pilha
        goto L5

    L4: iconst 0        ;; carrega false (0) na pilha

    L5: sipush 222 
        sipush 333
        if_icmpge L6    ;; se 222 >= 333 salta para L6
        iconst 1        ;; carrega true (1) na pilha
        goto L7

    L6: iconst 0        ;; carrega false (0) na pilha

    L7: iand            ;; desempilha dois valores, executa o and e empilha o resultado
        ifeq L1         ;; se algum teste falhou salta para L1

        ;; imprime true
        getstatic java/lang/System.out java/io/PrintStream
        ldc "true"
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        goto L2

    L1: ;; imprime false
        getstatic java/lang/System.out java/io/PrintStream
        ldc "false"
        invokevirtual java/io/PrintStream.print(java/lang/String)V

    L2: return
    }
}
```

Vale aqui ressaltar que a JVM não possui os tipos booleanos true e false. Estes tipos são emulados através dos inteiros 1 e 0, respectivamente. Para tal utilizamos as instruções "iconst 1" e "iconst 0".

Na tabela abaixo é possível ver as instruções geradas a partir do assembly acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Label | Instrução | Estado pilha após instrução |
| --- | --------- |  --------- |
| | sipush 111   | [ 111 ]     | 
| | sipush 222   | [ 111, 222 ] | 
| | if_icmpge L4      | [ ]     | 
| | iconst 1  |  [ 1 ] | 
| | goto L5     | [ 1 ]     | 
| ~~L4~~ | ~~iconst 0~~  |    | 
| L5 | sipush 222    |  [ 1, 222 ]  | 
| | sipush 333 |  [ 1, 222, 333 ] | 
| | if_icmpge L6      | [ 1 ]     | 
| | iconst 1 |  [ 1, 1 ]   | 
| | goto L7       |     | 
| ~~L6~~ | ~~iconst 0~~   |     | 
| L7 | iand   | [ 1 ] | 
| | ifeq L1      | [ ]     | 
| | getstatic ...   | [ getstatic ] | 
| | ldc "true"      | [ getstatic, "true" ]     | 
| | invokevirtual ...  |    | 
| | goto L2     |    | 
| ~~L1~~ | ~~getstatic ...~~  |  | 
| | ~~ldc "false"~~       |    | 
| | ~~invokevirtual ...~~  |    | 
| L2 | return      |     | 

As instruções ~~marcadas desta forma~~ não são executadas durante o fluxo de execução deste programa.

No final da execução o programa exibe a saída esperada: "true".


## Operador booleano or

Para implementarmos o operador booleano _or_ foi necessário introduzir a seguinte instrução:
- ior: desempilha dois inteiros, executa o _or_ e empilha o resultado

Vamos a um exemplo. A partir do programa Pascal abaixo:

```
program IfWithOr;
begin
    if (111<222) or (222<333) then
        writeln('true')
    else
        writeln('false');
end.
```

O POJ gera o seguinte JASM:

```
// Code generated by POJ 0.1
public class if_with_or {
    public static main([java/lang/String)V {
        sipush 111
        sipush 222
        if_icmpge L4         ;; se 111 >= 222 salta para L4
        iconst 1             ;; carrega true (1) na pilha
        goto L5

    L4: iconst 0             ;; carrega false (0) na pilha

    L5: sipush 222
        sipush 333
        if_icmpge L6         ;; se 222 >= 333 salta para L6
        iconst 1             ;; carrega true (1) na pilha
        goto L7

    L6: iconst 0             ;; carrega false (0) na pilha

    L7: ior                  ;; desempilha dois valores, executa o or e empilha o resultado
        ifeq L1              ;; se algum teste retornou true salta para L1

        ;; imprime true
        getstatic java/lang/System.out java/io/PrintStream
        ldc "true"
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V
        goto L2

    L1: ;; imprime false
        getstatic java/lang/System.out java/io/PrintStream
        ldc "false"
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

    L2: return
    }
}
```

Na tabela abaixo é possível ver as instruções geradas a partir do assembly acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Label | Instrução | Estado pilha após instrução |
| --- | --------- |  --------- |
| | sipush 111   | [ 111 ]     | 
| | sipush 222   | [ 111, 222 ] | 
| | if_icmpge L4      | [ ]     | 
| | iconst 1  |  [ 1 ] | 
| | goto L5     | [ 1 ]     | 
| ~~L4~~ | ~~iconst 0~~  |    | 
| L5 | sipush 222    |  [ 1, 222 ]  | 
| | sipush 333 |  [ 1, 222, 333 ] | 
| | if_icmpge L6      | [ 1 ]     | 
| | iconst 1 |  [ 1, 1 ]   | 
| | goto L7       |     | 
| ~~L6~~ | ~~iconst 0~~   |     | 
| L7 | ior   | [ 1 ] | 
| | ifeq L1      | [ ]     | 
| | getstatic ...   | [ getstatic ] | 
| | ldc "true"      | [ getstatic, "true" ]     | 
| | invokevirtual ...  |    | 
| | goto L2     |    | 
| ~~L1~~ | ~~getstatic ...~~  |  | 
| | ~~ldc "false"~~       |    | 
| | ~~invokevirtual ...~~  |    | 
| L2 | return      |     | 

As instruções ~~marcadas desta forma~~ não são executadas durante o fluxo de execução deste programa.

No final da execução o programa exibe a saída esperada: "true".



## Operador booleano not

Até aqui falamos sobre os operadores _and_ e _or_. E o operador _not_? Vamos a um exemplo.

A partir do programa Pascal abaixo:

```
program IfWithNot;
begin
    if not (111<222) then
        writeln('true')
    else
        writeln('false');
end.
```

O POJ gera o seguinte JASM:

```
// Code generated by POJ 0.1
public class if_with_not {
    public static main([java/lang/String)V {
        sipush 111
        sipush 222
        if_icmpge L4         ;; se 111 >= 222 salta para L4
        iconst 1             ;; carrega true (1) na pilha
        goto L5

    L4: iconst 0             ;; carrega false (0) na pilha

    L5: ifne L6              ;; se não zero (true), salta para L6
        iconst 1             ;; carrega true (1) na pilha
        goto L7

    L6: iconst 0             ;; carrega false (0) na pilha

    L7: ifeq L1              ;; se false salta para L1

        ;; imprime true
        getstatic java/lang/System.out java/io/PrintStream
        ldc "true"
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V
        goto L2

    L1: ;; imprime false
        getstatic java/lang/System.out java/io/PrintStream
        ldc "false"
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

    L2: return
    }
}
```

Vale aqui ressaltar que apesar da JVM ter as instruções _iand_ e _ior_, ela não possui uma instrução como _inot_. Esta "negação" da operação deve ser implementada com ifne e labels. O ifne (_if not equal_) salta para o label indicado caso o último valor da pilha não seja zero.

Na tabela abaixo é possível ver as instruções geradas a partir do assembly acima bem como o estado da pilha da JVM após a execução de cada instrução:

| Label  | Instrução | Estado pilha após instrução |
| ------ | --------- |  --------- |
|        | sipush 111   | [ 111 ]     | 
|        | sipush 222   | [ 111, 222 ] | 
|        | if_icmpge L4      | [ ]     | 
|        | iconst 1  |  [ 1 ] | 
|        | goto L5     | [ 1 ]     | 
| ~~L4~~ | ~~iconst 0~~  |    | 
| L5     | ifne L6       | [ ] |
|        | ~~iconst 1~~      |  |
|        | ~~goto L7~~ | |
|    L6  | iconst 0  | [ 0 ] |
|    L7  | ifeq L1  | |
|        | ~~getstatic ... java/io/PrintStream~~ | |
|        | ~~ldc "true"~~ | |
|        | ~~invokevirtual java/io/PrintStream.print(java/lang/String)V~~ | |
|        | ~~getstatic java/lang/System.out java/io/PrintStream~~ | |
|        |  ~~invokevirtual java/io/PrintStream.println()V~~ | |
|        | ~~goto L2~~ | |
|   L1   | getstatic ... java/io/PrintStream | [java/io/PrintStream] |
|        | ldc "false" | [java/io/PrintStream, "false"] |
|        | invokevirtual java/io/PrintStream.print(java/lang/String)V | [ ] |
|        | getstatic ... java/io/PrintStream | [java/io/PrintStream] |
|        | invokevirtual java/io/PrintStream.println()V | [] |
|   L2   |  return | [] |

As instruções ~~marcadas desta forma~~ não são executadas durante o fluxo de execução deste programa.

No final da execução o programa exibe a saída esperada: "false".



## Declaração e uso de Variáveis globais

A partir do programa [global_var_declaration.pas](/tests/valid_pascal_programs/global_var_declaration.pas):
```
program GlobalVarDeclaration;
var
    msg1, msg2 : string;
begin
    msg1 := 'Message 1!';
    msg2 := 'Message 2!';
    write (msg1, msg2);
end.
```

O POJ gera o seguinte Java Assembly ([global_var_declaration.jasm](/tests/valid_pascal_programs/global_var_declaration.jasm)):

```
// Code generated by POJ 0.1
public class global_var_declaration {

    ;; declaração de msg1
    public static msg1 java/lang/String
    
    ;; declaração de msg2
    public static msg2 java/lang/String

    public static main([java/lang/String)V {
        ;; msg1 := 'Message 1!';
        ldc "Message 1!"
        putstatic global_var_declaration.msg1 java/lang/String

        ;; msg2 := 'Message 2!';
        ldc "Message 2!"
        putstatic global_var_declaration.msg2 java/lang/String

        ;; write (msg1, msg2);
        getstatic java/lang/System.out java/io/PrintStream
        getstatic global_var_declaration.msg1 java/lang/String
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        getstatic global_var_declaration.msg2 java/lang/String
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        return
    }
}
```

Cabe aqui salientar que, para facilitar a compreensão, no exemplo acima as linhas iniciando com ";;" contém o trecho em Pascal que originou o JASM.

Em relação aos exemplos anteriores agora estamos utilizando duas novas instruções da JVM:
- putstatic \<VAR_ID\> \<VAR_TYPE\>: retira da pilha um valor e armazena na variável global \<VAR_ID\> do tipo \<VAR_TYPE\>
- getstatic \<VAR_ID\> \<VAR_TYPE\>: varrega na pilha o valor da variável global \<VAR_ID\> do tipo \<VAR_TYPE\>



## Estrutura de controle Repeat

Abaixo temos a sintaxe do _Repeat_:

```
1:    repeat            
2:        <bloco código>
3:    until <condição>;
```

O POJ implementa o seguinte comportamento:
- Na linha 1, ao reconhecer o _token_ _repeat_, gera e emite um _label_ (L1) que indica onde inicia o laço de repetição
- Na linha 2 o bloco de código é traduzido para JASM
- Na linha 3 a condição é avaliada e, caso seja válida (_true_) a execução salta para L1


Vamos a um exemplo que imprime os números de 10 até 19. A partir do programa [repeat.pas](/tests/valid_pascal_programs/repeat.pas):

```
program RepeatExample;
var
    i: integer;
begin
    i := 10;
    repeat
        writeln ('i=', i);
        i := i + 1;
    until i = 20;
end.
```

O POJ gera o seguinte Java Assembly ([repeat.jasm](/tests/valid_pascal_programs/repeat.jasm)):

```
// Code generated by POJ 0.1
public class repeat {
    ;; var i: integer;
    public static i I
    
    public static main([java/lang/String)V {
        ;; i := 10;
        sipush 10
        putstatic repeat.i I

    L3: ;; repeat

        ;; writeln ('i=', i);
        getstatic java/lang/System.out java/io/PrintStream
        ldc "i="
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        getstatic repeat.i I
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V
        
        ;; i := i + 1;
        getstatic repeat.i I
        sipush 1
        iadd 
        putstatic repeat.i I

        ;; until i = 20;
        getstatic repeat.i I
        sipush 20
        if_icmpne L4
        iconst 1 
        goto L5

    L4: iconst 0 

    L5: ifeq L3
        return
    }
}
```

Neste JASM não foram utilizadas novas instruções da JVM.



## Estrutura de controle While

A estrutura _While_ pode ser vista como uma variação da _Repeat_, onde no caso do _Repeat_ o teste é executado no final enquanto que no _While_ o teste é executado no início. _Repeat_ sempre executa o bloco de código pelo menos uma vez, enquanto que o _While_ executa 0 ou mais vezes.

Abaixo temos a sintaxe do _While_:

```
1:    while <condição> do
2:    begin
3:        <bloco código>
4:    end;
```

O POJ implementa o seguinte comportamento:
- Na linha 1, ao reconhecer o _token_ _while_, executa os seguintes passos:
  - gera e emite um _label_ (L1) que indica onde está o condicional do _while_
  - gera um _label_ (L2) que indica o término do _while_
  - avalia a condição e, caso seja inválida (false) a execução salta para L2
- A linha 2 apenas indica o início do bloco
- Na linha 3 o bloco de código é traduzido para JASM
- Na linha 4 são executados os seguintes passos:
  - a execução salta para L1
  - emite o _label_ L2

Vamos a um exemplo. A partir do programa [while_example.pas](/tests/valid_pascal_programs/while_example.pas):

```
program WhileExample;
var
    i: integer;
begin
    i := 10;
    while i < 20 do
    begin
        writeln ('i=', i);
        i := i + 1;
    end;
end.
```

O POJ gera o seguinte Java Assembly ([while_example.jasm](/tests/valid_pascal_programs/while_example.jasm)):

```
// Code generated by POJ 0.1
public class while_example {
    ;; var i: integer;
    public static i I

    public static main([java/lang/String)V {
        ;; i := 10;
        sipush 10
        putstatic while_example.i I

    L3: ;; while i < 20 do
        getstatic while_example.i I
        sipush 20
        if_icmpge L4
        iconst 1 

        ;; end; (do while)
        goto L5

    L4: iconst 0 

    L5: ifeq L2
        ;; writeln ('i=', i);
        getstatic java/lang/System.out java/io/PrintStream
        ldc "i="
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        getstatic while_example.i I
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V
        
        ;; i := i + 1;
        getstatic while_example.i I
        sipush 1
        iadd 
        putstatic while_example.i I
        goto L3

    L2: return
    }
}
```

Em comparação com os exemplos anteriores, não foram utilizadas novas instruções da JVM.



## Estrutura de controle For

Abaixo temos a sintaxe do _For_:

```
1:  for <var> := <início> to <fim> do
2:  begin
3:      <bloco código>
4:  end;
```

O POJ implementa o seguinte comportamento:
- Na linha 1, ao reconhecer o _token_ _for_, são executados os seguintes passos:
  - inicializa \<var\> com o valor \<início\>
  - gera e emite um _label_ (L1) que indica onde está o condicional do _for_
  - gera um _label_ (L2) que indica o término do _for_
  - avalia se \<var\> é \<= a \<fim\> e, caso seja inválida (false) a execução salta para o _label_ L2
- A linha 2 apenas indica o início do bloco
- Na linha 3 o bloco de código é traduzido para JASM
- Na linha 4 são executados os seguintes passos:
  - incrementa \<var\> em 1 unidade
  - a execução salta para o _label_ L1
  - emite o _label_ L2

Para a sua correta implementação o for engloba as seguintes tarefas:
- inicializar a variável definida no _for_
- incrementar/decrementar esta variável automaticamente no final do laço
- validar no início da sentença se o bloco deve ser executado


Vamos ao exemplo. A partir do programa [for_example.pas](/tests/valid_pascal_programs/for_example.pas):

```
program ForExample;
var
    i: integer;
begin
    for i := 10 to 19 do
    begin
        writeln ('inc i=', i);
    end;
end.
```

O POJ gera o seguinte Java Assembly ([for_example.jasm](/tests/valid_pascal_programs/for_example.jasm)):

```
// Code generated by POJ 0.1
public class for_example {
    ;; var i: integer;
    public static i I

    public static main([java/lang/String)V {
        ;; i := 10
        sipush 10
        putstatic for_example.i I

    L3: ;; i <= 19 ?
        getstatic for_example.i I
        sipush 19
        if_icmpgt L2

        ;; writeln ('inc i=', i);
        getstatic java/lang/System.out java/io/PrintStream
        ldc "inc i="
        invokevirtual java/io/PrintStream.print(java/lang/String)V
        getstatic java/lang/System.out java/io/PrintStream
        getstatic for_example.i I
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

        ;; i++ (implícito pelo for)
        getstatic for_example.i I
        sipush 1
        iadd 
        putstatic for_example.i I

        ;; end; (do for)
        goto L3

    L2: return
    }
}
```

Em comparação com os exemplos anteriores, não foram utilizadas novas instruções da JVM.



## Definição e uso de procedures

Para um primeiro exemplo, vamos invocar uma procedure sem parâmetros. A partir do programa [procedure_call_wo_params.pas](/tests/valid_pascal_programs/procedure_call_wo_params.pas):

```
program procedure_call_wo_params;

procedure myprocedure;
begin
    write('Hello from myprocedure!');
end;

begin
    write('Hello from main!');
    myprocedure();
end.

```

O POJ gera o seguinte Java Assembly ([procedure_call_wo_params.jasm](/tests/valid_pascal_programs/procedure_call_wo_params.jasm)):

```
// Code generated by POJ 0.1
public class procedure_call_wo_params {

    ;; procedure myprocedure;
    static myprocedure()V {

        ;; write('Hello from myprocedure!');
        getstatic java/lang/System.out java/io/PrintStream
        ldc "Hello from myprocedure!"
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        return
    }

    ;; bloco principal (main)
    public static main([java/lang/String)V {

        ;; write('Hello from main!');
        getstatic java/lang/System.out java/io/PrintStream
        ldc "Hello from main!"
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        ;; myprocedure();
        invokestatic procedure_call_wo_params.myprocedure()V 

        return
    }
}
```

Neste assembly vemos que para invocar uma _procedure_ a JVM utiliza a instrução "invokestatic procedure_call_wo_params.myprocedure()V" onde:
- invokestatic é a instrução que recebe como argumento a assinatura completa do método a ser chamado;
- procedure_call_wo_params é o nome da classe;
- myprocedure()V é assinatura completa do método com seus parâmetros (neste exemplo nenhum) e o tipo de retorno (neste exemplo V - _void_ - que indica nenhum).



Agora vamos utilizar um exemplo com passagem de parâmetros. A partir do programa [procedure_call_add_numbers.pas](/tests/valid_pascal_programs/procedure_call_add_numbers.pas):

```
program procedure_call_add_numbers;

procedure add(value1, value2: integer);
begin
    writeln(value1 + value2);
end;

begin
    add(4, 6);
end.

```

O POJ gera o seguinte Java Assembly ([procedure_call_add_numbers.jasm](/tests/valid_pascal_programs/procedure_call_add_numbers.jasm)):

```
// Code generated by POJ 0.1
public class procedure_call_add_numbers {

    ;; procedure add(value1, value2: integer);
    static add(I, I)V {

        ;; write(value1 + value2);
        getstatic java/lang/System.out java/io/PrintStream
        iload 0              ;; carrega o parâmetro 0 (value1)
        iload 1              ;; carrega o parâmetro 1 (value2)
        iadd 
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

        return
    }

    ;; Bloco principal (main)
    public static main([java/lang/String)V {

        ;; add(4, 6);
        sipush 4             ;; empilha o primeiro argumento (4)
        sipush 6             ;; emiplha o segundo argumento (6)
        invokestatic procedure_call_add_numbers.add(I, I)V 

        return
    }
}
```

Neste assembly vemos que a assinatura do método add indica os 2 inteiros que são esperados pelo método.



## Definição e uso de functions

A partir do programa [function_call_with_two_params.pas](/tests/valid_pascal_programs/function_call_with_two_params.pas):

```
program function_call_with_two_params;

function addvalues(value1, value2: integer) : integer;
begin
    addvalues := value1 + value2;
end;

begin
    writeln('2+4=', addvalues(2, 4));
end.
```

O POJ gera o seguinte Java Assembly ([function_call_with_two_params.jasm](/tests/valid_pascal_programs/function_call_with_two_params.jasm)):

```
// Code generated by POJ 0.1
public class function_call_with_two_params {

    ;; function addvalues(value1, value2: integer) : integer;
    static addvalues(I, I)I {

        ;; addvalues := value1 + value2;
        iload 0              ;; carrega o parâmetro 0 (value1)
        iload 1              ;; carrega o parâmetro 1 (value2)
        iadd 
        istore 100           ;; posição 100 guarda o retorno da função
        iload 100            ;; empilha o retorno da função

        ireturn              ;; encerra a função deixando o resultado inteiro na pilha
    }

    ;; Bloco principal (main)
    public static main([java/lang/String)V {

        ;; writeln('2+4=', ...)
        getstatic java/lang/System.out java/io/PrintStream
        ldc "2+4="
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        ;; writeln(..., addvalues(2, 4));
        getstatic java/lang/System.out java/io/PrintStream

        ;; aqui código para invocar addvalues(2, 4)
        sipush 2             ;; empilha o primeiro argumento (2)
        sipush 4             ;; empilha o segundo argumento (4)

        ;; aqui código para invocar writeln com retorno addvalues
        invokestatic function_call_with_two_params.addvalues(I, I)I 
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

        return
    }
}
```

Com este exemplo foi possível identificar que:
- Para invocar um método a JVM utilizou a instrução "_function_call_with_two_params.addvalues(I, I)I_" onde:
    - _invokestatic_ é a instrução que recebe como argumento a assinatura completa do método a ser chamado;
    - _function_call_with_two_params é o nome da classe;
    - _addvalues(I, I)I_ é assinatura completa do método com seus parâmetros (neste exemplo dois inteiros) e o tipo de retorno (neste exemplo um inteiro);
- Instrução _ireturn_ encerra a função e deixa na pilha o inteiro de retorno.

Os mais atentos devem ter notado o "istore 100" acima e pensado:
- Por que guardar o retorno da função em uma variável local? Isso se deve ao fato de que em Pascal o valor de retorno de uma função pode ser definido N vezes durante a função, mas só podemos empilhar um resultado na JVM;
- Por que na posição 100? As variáveis locais de uma função ou procedimento iniciam na posição 0 então arbitrariamente foi escolhido a posição 100 para guardar o retorno;
- Mas não seria possível otimizar para que neste exemplo não fosse gerado o istore 100 e iload 100, que neste contexto são desnecessários? Sim, seria, mas o POJ não implementa a [fase de otimizações](https://www.geeksforgeeks.org/phases-of-a-compiler/?ref=lbp) existente em compiladores de mercado, algo que pode ser implementado futuramente.


## Variáveis locais

A partir do programa [local_vars.pas](/tests/valid_pascal_programs/local_vars.pas):

```
program local_vars;

function addvalues(value1, value2: integer) : integer;
var
    total: integer;
begin
    total := value1 + value2;
    addvalues := total;
end;

begin
    writeln(addvalues(2, 4));
end.
```

O POJ gera o seguinte Java Assembly ([local_vars.jasm](/tests/valid_pascal_programs/local_vars.jasm)):

```
// Code generated by POJ 0.1
public class local_vars {

    ;; function addvalues(value1, value2: integer) : integer;
    static addvalues(I, I)I {

        ;; var total: integer; (total fica com slot 2)
        ;; total := value1 + value2;
        iload 0              ;; carrega o parâmetro 0 (value1)
        iload 1              ;; carrega o parâmetro 1 (value2)
        iadd 
        istore 2

        ;; addvalues := total;
        iload 2
        istore 100           ;; posição 100 guarda o retorno da função

        iload 100            ;; empilha o retorno da função

        ireturn              ;; encerra a função deixando o resultado inteiro na pilha
    }

    ;; Bloco principal (main)
    public static main([java/lang/String)V {
        getstatic java/lang/System.out java/io/PrintStream

        ;; aqui código para invocar addvalues(2, 4)
        sipush 2 ;; empilha o primeiro argumento (2)
        sipush 4 ;; empilha o segundo argumento (4)
        invokestatic local_vars.addvalues(I, I)I 

        ;; writeln(...);
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V
        
        return
    }
}
```


Os mais atentos devem ter notado que a variável local (total) ficou associada a posição 2. Isso se deve ao fato que os argumentos são considerados variáveis locais na JVM. Com isso value1 e value2 ficaram, respectivamente, com as posições 0 e 1.



## Fatorial recursivo

Um dos objetivos do projeto era podermos calcular o fatorial de forma recursiva, lendo o número a ser calculado da entrada padrão. As implementações no POJ até o momento possibilitaram este objetivo. 
Dito isso, a partir do programa [fatorial.pas](/tests/valid_pascal_programs/fatorial.pas):

```
program fatorial;

var numero : integer;

function fatorial(n : integer) : integer;
begin
    if n<0 then fatorial := 0
    else begin
        if n<=1 then fatorial := 1
        else fatorial := n * fatorial(n-1);
    end;
end;

begin
    write('Introduza numero inteiro: ');
    readln(numero);
    writeln;
    writeln('O fatorial de ', numero, ' e: ', fatorial(numero));
end.
```

O POJ gera o seguinte Java Assembly ([fatorial.jasm](/tests/valid_pascal_programs/fatorial.jasm)):

```
// Code generated by POJ 0.1
public class fatorial {
    ;; var numero : integer;
    public static numero I

    ;; function fatorial(n : integer) : integer;
    static fatorial(I)I {
        ;; if n<0 then fatorial := 0
        iload 0
        sipush 0
        if_icmpge L4
        iconst 1 
        goto L5
    L4: iconst 0 
    L5: ifeq L1
        sipush 0
        istore 100
        goto L2

    L1: ;; if n<=1 then fatorial := 1
        iload 0
        sipush 1
        if_icmpgt L9
        iconst 1 
        goto L10
    L9: iconst 0 
    L10:ifeq L6
        sipush 1
        istore 100
        goto L7

    L6: ;; fatorial := n * fatorial(n-1);
        iload 0
        iload 0
        sipush 1
        isub 
        invokestatic fatorial.fatorial(I)I 
        imul 
        istore 100

L7: L2: iload 100
        ireturn 
    }

    // Bloco principal (Main)
    public static main([java/lang/String)V {

        ;; write('Introduza numero inteiro: ');
        getstatic java/lang/System.out java/io/PrintStream
        ldc "Introduza numero inteiro: "
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        ;; readln(numero);
        invokestatic java/lang/System.console()java/io/Console
        invokevirtual java/io/Console.readLine()java/lang/String
        invokestatic java/lang/Integer.parseInt(java/lang/String)I
        putstatic fatorial.numero I

        ;; writeln;
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

        ;; writeln('O fatorial de ', ...);
        getstatic java/lang/System.out java/io/PrintStream
        ldc "O fatorial de "
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        ;; writeln(..., numero, ...);
        getstatic java/lang/System.out java/io/PrintStream
        getstatic fatorial.numero I
        invokevirtual java/io/PrintStream.print(I)V

        ;; writeln(..., ' e: ', ...);
        getstatic java/lang/System.out java/io/PrintStream
        ldc " e: "
        invokevirtual java/io/PrintStream.print(java/lang/String)V

        ;; writeln(..., fatorial(numero));
        getstatic java/lang/System.out java/io/PrintStream
        getstatic fatorial.numero I
        invokestatic fatorial.fatorial(I)I 
        invokevirtual java/io/PrintStream.print(I)V
        getstatic java/lang/System.out java/io/PrintStream
        invokevirtual java/io/PrintStream.println()V

        return
    }
}
```
